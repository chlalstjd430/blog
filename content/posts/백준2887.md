---
title: "ë°±ì¤€ 2887 - í–‰ì„±í„°ë„"
date: 2020-01-15T21:00:48+09:00
categories: ["ë°±ì¤€ ë¬¸ì œí’€ì´"]
tags: ["algoritm","ë°±ì¤€","í–‰ì„±í„°ë„","2887"]
---

### [ë°±ì¤€ ë¬¸ì œ ë°”ë¡œê°€ê¸°](https://www.acmicpc.net/problem/2887)
<br>
<br>
<br>
#### ì‚¬ìš© ì–¸ì–´

- C++



#### ì ìš© ì•Œê³ ë¦¬ì¦˜

- ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬
- í•©ì§‘í•© ì°¾ê¸°



#### ë¬¸ì œí’€ì´

ì¼ë°˜ì ìœ¼ë¡œ ë‚œì´ë„ê°€ ì‰¬ìš´ ìµœì†Œ ìŠ¤íŒ¨ë‹ íŠ¸ë¦¬ ë¬¸ì œë¥¼ í’€ ë•Œ, ê°€ì¤‘ì¹˜ ê°’ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ í›„ í¬ë¥´ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì„ ì ìš©í•˜ë©´ ë¬¸ì œë¥¼ ì‰½ê²Œ í’€ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ í•´ë‹¹ ë¬¸ì œëŠ” ê°€ì¤‘ì¹˜ ê°’ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í•  ë•Œ ë‹¤ë¥¸ ë¬¸ì œì™€ ë‹¤ë¥´ë‹¤ëŠ” ê²ƒì„ ëŠë‚„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë¨¼ì € ì •ë ¬ì„ ìœ„í•´ì„œ ë¬¸ì œ ì¤‘ ì´ í•œ ë¬¸ì¥ì„ ì˜ ì´í•´í•  í•„ìš”ê°€ ìˆê² ìŠµë‹ˆë‹¤


> ë‘ í–‰ì„± A(xA, yA, zA)ì™€ B(xB, yB, zB)ë¥¼ í„°ë„ë¡œ ì—°ê²°í•  ë•Œ ë“œëŠ” ë¹„ìš©ì€ min(|xA-xB|, |yA-yB|, |zA-zB|)ì´ë‹¤.




ì´ ë¬¸ì¥ì„ í†µí•´ ìµœì¢…ì ìœ¼ë¡œ x,y,z ê°’ì„ ê°ê° ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬í›„ ëª¨ë“  ê°’ë“¤ì„ vectorì— ë„£ì–´ ì •ë ¬í•œ ë’¤ í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì„ ì ìš©í•˜ë©´ ë‹µì´ ë‚˜ì˜¬ ê²ƒì„ ì˜ˆìƒí• ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.

ë¨¼ì € Planet í´ë˜ìŠ¤ì™€, Planet í´ë˜ìŠ¤ë¥¼ x,y,z ê°’ìœ¼ë¡œ ì •ë ¬ í›„ ë‹´ì•„ì¤„ìˆ˜ ìˆëŠ” Edge í´ë˜ìŠ¤ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.


~~~c++
//í–‰ì„± ì •ë³´ë¥¼ ë‹´ì•„ì¤„ Planet í´ë˜ìŠ¤
class Planet
{
public:
	int node[3];
	int index;

	Planet(int x, int y, int z, int index) {
		node[0] = x;
		node[1] = y;
		node[2] = z;
		this->index = index;
	}



};

//Planet Classë¥¼ x,y,zê¸°ì¤€ìœ¼ë¡œ ê°ê° sortë¥¼ ìœ„í•´ ë§Œë“¤ì–´ì¤ë‹ˆë‹¤.
bool cmpX (Planet &planet, Planet &planet2) {
	return planet.node[0] < planet2.node[0];
}
bool cmpY(Planet &planet, Planet &planet2) {
	return planet.node[1] < planet2.node[1];
}
bool cmpZ(Planet &planet, Planet &planet2) {
	return planet.node[2] < planet2.node[2];
}

//sortì´í›„ ê°€ì¤‘ì¹˜ ì •ë³´ë¥¼ ë‹´ì•„ì¤„ Edge í´ë˜ìŠ¤ë¥¼ ë§Œë“¤ì–´ì¤ë‹ˆë‹¤.
class Edge
{
public:
	int x, y;
	int value;

	Edge(int x, int y, int value) {
		this->x = x;
		this->y = y;
		this->value = value;
	}

	bool operator <(Edge &edge) {
		return this->value < edge.value;
	}
};
~~~



ì´í›„ ì•ì„œ ë§ì”€ë“œë¦° ê²ƒì²˜ëŸ¼ x,y,z ê¸°ì¤€ìœ¼ë¡œ Plaent Classë¥¼ ì •ë ¬ í›„ Edge Classì— ë‹´ì•„ ìµœì¢…ì ìœ¼ë¡œ Edge Classë¥¼ ì •ë ¬ í›„ í¬ë£¨ìŠ¤ì¹¼ ì•Œê³ ë¦¬ì¦˜ì„ ì ìš©í•˜ë©´ ê²°ê³¼ê°€ ë‚˜ì˜µë‹ˆë‹¤.

~~~c++
//ì •ë ¬ ê³¼ì •
sort(planet.begin(), planet.end(), cmpX);
	for (int i = 0; i < N - 1; i++) {
		edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[0] - planet[i + 1].node[0])));
	}

	sort(planet.begin(), planet.end(), cmpY);
	for (int i = 0; i < N - 1; i++) {
		edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[1] - planet[i + 1].node[1])));
	}

	sort(planet.begin(), planet.end(), cmpZ);
	for (int i = 0; i < N - 1; i++) {
		edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[2] - planet[i + 1].node[2])));
	}

	sort(edge.begin(), edge.end());
~~~




#### ìµœì¢…ì½”ë“œ
~~~c
#include <iostream>
#include <algorithm>
#include <vector>
#include <cmath>

using namespace std;

class Planet
{
public:
	int node[3];
	int index;

	Planet(int x, int y, int z, int index) {
		node[0] = x;
		node[1] = y;
		node[2] = z;
		this->index = index;
	}



};
bool cmpX (Planet &planet, Planet &planet2) {
	return planet.node[0] < planet2.node[0];
}
bool cmpY(Planet &planet, Planet &planet2) {
	return planet.node[1] < planet2.node[1];
}
bool cmpZ(Planet &planet, Planet &planet2) {
	return planet.node[2] < planet2.node[2];
}

class Edge
{
public:
	int x, y;
	int value;

	Edge(int x, int y, int value) {
		this->x = x;
		this->y = y;
		this->value = value;
	}

	bool operator <(Edge &edge) {
		return this->value < edge.value;
	}
};

int getParent(int parent[], int x) {
	if (parent[x] == x) return x;
	return getParent(parent, parent[x]);
}

void unionParent(int parent[], int x, int y) {
	x = getParent(parent, x);
	y = getParent(parent, y);

	if (x > y) parent[x] = y;
	else parent[y] = x;
}

bool findParent(int parent[], int x, int y) {
	x = getParent(parent, x);
	y = getParent(parent, y);

	if (x == y) return true;
	return false;
}
int dist[100002];


vector<Planet> planet;
vector<Edge> edge;

int main() {
	int N;
	int x, y, z;
	int sum = 0;
	cin >> N;
	for (int i = 0; i < N; i++) {
		cin >> x >> y >> z;
		planet.push_back(Planet(x, y, z, i));
	}

	for (int i = 0; i <= N; i++) {
		dist[i] = i;
	}

	sort(planet.begin(), planet.end(), cmpX);
	for (int i = 0; i < N - 1; i++) {
		edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[0] - planet[i + 1].node[0])));
	}

	sort(planet.begin(), planet.end(), cmpY);
	for (int i = 0; i < N - 1; i++) {
		edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[1] - planet[i + 1].node[1])));
	}

	sort(planet.begin(), planet.end(), cmpZ);
	for (int i = 0; i < N - 1; i++) {
		edge.push_back(Edge(planet[i].index, planet[i + 1].index, abs(planet[i].node[2] - planet[i + 1].node[2])));
	}

	sort(edge.begin(), edge.end());

	for (int i = 0; i < edge.size(); i++) {
		if (!(findParent(dist, edge[i].x, edge[i].y))) {
			sum += edge[i].value;
			unionParent(dist, edge[i].x, edge[i].y);
		}

	}

	cout << sum;
}
~~~



ì¶”ê°€ì ì¸ ì§ˆë¬¸ì‚¬í•­ ìˆìœ¼ì‹œë©´ ì–¸ì œë“ ì§€ ëŒ“ê¸€ ë‹¬ì•„ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤ğŸ˜Š
